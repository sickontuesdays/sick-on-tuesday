<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>S!ck on Tuesdays — Command Grid (Full-Width, Live Push, Top Controls)</title>
<meta name="description" content="Destiny 2 command-center grid with full-width layout, responsive left tabs, centered lock + right visibility controls, smooth drag with live collision, and snap on drop.">

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">

<style>
  :root{
    --bg:#0a0e13; --panel:#0f1520; --panel2:#121a28;
    --ink:#e7eefc; --muted:#94a7c4; --border:#1f2b3e;
    --arc:#7dd3fc; --arc2:#60a5fa; --good:#34d399; --bad:#fb7185;

    --cols: 12;
    --colW: 90px;   /* grid column width unit */
    --rowH: 90px;   /* grid row height unit */
    --gap: 14px;    /* grid gap */
    --leftTabsW: 260px;     /* fixed width for layouts panel */
    --maxPageW: 100vw;      /* full-width as requested */
  }
  @media (max-width:1300px){ :root{ --colW:84px; --rowH:86px; } }
  @media (max-width:1100px){ :root{ --colW:78px; --rowH:80px; } }
  @media (max-width: 900px){ :root{ --colW:70px; --rowH:74px; } }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; overflow-x:hidden; /* no horizontal scroll */
    font:16px/1.55 Rajdhani, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    color:var(--ink);
    background:
      radial-gradient(1100px 600px at 100% -10%, rgba(18,34,56,.55), transparent 60%),
      radial-gradient(900px 500px at -20% 110%, rgba(24,40,62,.55), transparent 60%),
      linear-gradient(180deg, #081018 0%, #060a10 100%);
  }
  body::before{
    content:""; position:fixed; inset:0; pointer-events:none;
    background:
      linear-gradient(transparent 31px, rgba(125,211,252,.05) 32px),
      linear-gradient(90deg, transparent 31px, rgba(125,211,252,.05) 32px);
    background-size:32px 32px;
    mask-image: linear-gradient(180deg, transparent, #000 12%, #000 88%, transparent);
  }

  .wrap{
    width: min(2000px, var(--maxPageW)); /* full window width */
    margin: 16px auto 60px;
    padding: 0 12px; /* tiny side padding to avoid accidental overflow */
  }

  header{
    display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:14px;
  }
  .brand{display:flex; align-items:baseline; gap:12px}
  .brand h1{margin:0; font-size:28px; font-weight:700; letter-spacing:.04em}
  .brand .badge{color:var(--muted); font-size:13px; letter-spacing:.14em; text-transform:uppercase}

  /* ============== PAGE LAYOUT ==============
     Two columns that use the full width:
     - Column 1: Left tabs (fixed width)
     - Column 2: Controls bar (top) + Grid (below) occupy remaining width
  */
  .layout{
    display:grid;
    grid-template-columns: var(--leftTabsW) 1fr;
    grid-template-areas:
      "left controls"
      "left grid";
    column-gap: 16px;
    align-items:start;
  }

  /* ===== Left Layout Tabs ===== */
  .leftTabs{ grid-area:left; position:sticky; top:86px; width:var(--leftTabsW); }
  .tabs{
    border:1px solid var(--border); border-radius:12px; overflow:hidden;
    background:linear-gradient(180deg,#0f1520,#101a28);
    box-shadow:0 8px 28px rgba(0,0,0,.35);
  }
  .tabRow{ display:flex; align-items:center; gap:8px; padding:0; border-bottom:1px solid var(--border); }
  .colorChip{
    width:16px; height:16px; border-radius:4px; margin-left:10px;
    border:1px solid var(--border); cursor:pointer; flex:0 0 auto;
    box-shadow: inset 0 0 0 2px rgba(0,0,0,.15);
  }
  body.locked .colorChip{ cursor:not-allowed; opacity:.6; pointer-events:none; }
  .tabCheck{ margin-left:10px; width:16px; height:16px; flex:0 0 auto; accent-color: var(--arc); }
  .tabBtn{
    flex:1 1 auto; text-align:left; padding:10px 12px; border:0; background:transparent; color:var(--ink);
    cursor:pointer; font-weight:700; letter-spacing:.04em;
  }
  .tabBtn:hover{ background:#111b2a; }
  .tabBtn.active{ background:#122132; }
  .addBtn{
    width:100%; text-align:left; padding:10px 12px; border:0; background:#0e1726; color:var(--ink);
    cursor:pointer; font-weight:700; letter-spacing:.04em;
  }
  .addBtn:hover{ background:#111b2a; }
  .bulkBar{ display:flex; align-items:center; gap:8px; padding:8px; border-top:1px solid var(--border); background:#0e1726; }
  .toggleBtn{
    flex:1 1 auto; padding:8px 10px; border:1px solid var(--border); border-radius:8px; cursor:pointer;
    background:#0e1726; color:var(--ink); font-weight:700; text-align:left;
  }
  .toggleBtn[aria-pressed="true"]{ background:#122132; }
  .deleteBtn{
    flex:0 0 auto; padding:8px 10px; border:1px solid var(--border); border-radius:8px; cursor:pointer;
    background:linear-gradient(180deg,#2b0f14,#370c12); border-color:#4a1018; color:#ffb3bd; font-weight:700;
    opacity:.55; pointer-events:none; white-space:nowrap;
  }
  .deleteBtn.enabled{ opacity:1; pointer-events:auto; }
  .tabFooter{ padding:8px 12px; color:var(--muted); font-size:12px }

  /* ===== Controls above the Grid (center + right) ===== */
  .controls{ grid-area:controls; display:flex; align-items:center; gap:12px; margin-bottom:12px; }
  .controls .spacer{ flex:1 1 auto; }
  .controls .center{ flex:0 0 auto; }
  .controls .right{ flex:0 0 auto; margin-left:auto; }

  /* Lock toggle: centered */
  #lockToggle{
    display:inline-flex; align-items:center; gap:10px;
    border:1px solid var(--border); border-radius:12px;
    background:linear-gradient(180deg,#132033,#0e1726);
    padding:8px 12px; cursor:pointer; user-select:none;
    font-size:14px; color:var(--ink);
  }
  #lockToggle .dot{ width:12px; height:12px; border-radius:999px; background:var(--good); box-shadow:0 0 12px var(--good); }
  body.locked #lockToggle .dot{ background:#9b1c1c; box-shadow:0 0 10px #9b1c1c; }
  body.locked #lockToggle .text::after{ content:"Layout Locked"; }
  #lockToggle .text::after{ content:"Editing Enabled"; }
  body.locked .bar{ cursor:default; }
  body.locked .resize{ display:none; }

  /* Panel visibility dropdown: right aligned */
  .controlBox{
    border:1px solid var(--border); border-radius:12px;
    background:linear-gradient(180deg,#0f1520,#101a28);
    box-shadow:0 8px 28px rgba(0,0,0,.35);
    overflow:hidden; min-width:240px;
  }
  .controlHeader{
    padding:10px 12px; font-weight:700; letter-spacing:.06em; cursor:pointer;
    border-bottom:1px solid var(--border);
    display:flex; align-items:center; justify-content:space-between;
  }
  .controlHeader:hover{ background:#111b2a; }
  .caret{ transition: transform .15s ease; }
  .controlBody{ display:none; max-height:420px; overflow:auto; }
  .controlBox.open .controlBody{ display:block; }
  .controlBox.open .caret{ transform: rotate(180deg); }
  .checkRow{ display:flex; align-items:center; gap:8px; padding:8px 12px; font-size:14px; color:var(--muted) }
  .checkRow input{ transform: translateY(1px); }

  /* ===== The Grid (information panels) ===== */
  .grid{ grid-area:grid;
    position:relative;
    display:grid;
    grid-template-columns: repeat(var(--cols), minmax(var(--colW), 1fr));
    grid-auto-rows: var(--rowH);
    gap: var(--gap);
  }
  .card{
    position:relative;
    background:linear-gradient(180deg, var(--panel) 0%, var(--panel2) 140%);
    border:1px solid var(--border);
    border-radius:14px;
    box-shadow:0 6px 24px rgba(2,10,20,.35);
    overflow:hidden;
    user-select:none;
    will-change: transform;
  }
  .card.hide{ display:none !important; }
  .bar{
    height:38px; display:flex; align-items:center; justify-content:space-between;
    padding:0 10px; border-bottom:1px solid var(--border);
    background:linear-gradient(180deg,#132033,#0e1726);
    cursor:grab;
  }
  .bar:active{ cursor:grabbing; }
  .title{ font-weight:700; letter-spacing:.04em }
  .handle{ font-weight:700; letter-spacing:.2em; color:var(--muted); user-select:none }
  .content{ padding:12px; color:var(--muted); font-size:14px }
  a{color:var(--arc); text-decoration:none}
  a:hover{text-decoration:underline}
  .resize{
    position:absolute; width:16px; height:16px; right:6px; bottom:6px;
    border:1px solid var(--border); border-radius:3px;
    background:linear-gradient(135deg, #0e1726 0%, #132033 100%);
    cursor:nwse-resize;
  }
  .dragging{ opacity:.96; box-shadow:0 16px 36px rgba(0,0,0,.6); z-index:5; }

  /* ====== Narrow screens: place Layout tabs ABOVE the grid horizontally ====== */
  @media (max-width: 1200px){
    .layout{
      grid-template-columns: 1fr;
      grid-template-areas:
        "controls"
        "left"
        "grid";
    }
    .leftTabs{ position:static; top:auto; width:auto; margin-bottom:12px; }
    .tabs{ display:flex; flex-wrap:wrap; gap:8px; padding:8px; border-radius:12px; }
    .tabRow{ border:0; padding:0; gap:8px; background:#0f1520; border:1px solid var(--border); border-radius:10px; }
    .tabBtn{ padding:8px 10px; }
    .addBtn{ width:auto; padding:8px 10px; }
    .bulkBar{ border-top:0; background:transparent; padding:0; gap:8px; }
  }

  /* Popover (rename/color) */
  .popover{
    position:fixed; z-index:50; width:240px; border:1px solid var(--border); border-radius:10px;
    background:linear-gradient(180deg,#0f1520,#101a28);
    box-shadow:0 12px 40px rgba(0,0,0,.5); padding:10px; display:none;
  }
  .popover.open{ display:block; }
  .popover label{ display:block; font-size:12px; color:var(--muted); margin:6px 0 4px }
  .popover input[type="text"]{
    width:100%; padding:8px 10px; border-radius:8px; border:1px solid var(--border);
    background:#0e1726; color:var(--ink);
  }
  .popover input[type="color"]{
    width:100%; height:36px; border:1px solid var(--border); border-radius:8px; background:transparent; padding:0;
  }
  .popover .row{ display:flex; gap:8px; margin-top:10px }
  .popover button{
    flex:1; padding:8px 10px; border:1px solid var(--border); border-radius:8px; cursor:pointer;
    background:#0e1726; color:var(--ink); font-weight:700;
  }
  .popover button:hover{ background:#111b2a; }
  .popover .danger{ margin-top:8px; width:100%; background:linear-gradient(180deg,#2b0f14,#370c12);
    border-color:#4a1018; color:#ffb3bd; }

  /* Confirm modal + Undo snackbar reused from previous build */
  .modal{ position:fixed; inset:0; display:none; z-index:60; }
  .modal.open{ display:block; }
  .modal .backdrop{ position:absolute; inset:0; background:rgba(0,0,0,.55); backdrop-filter: blur(2px); }
  .modal .dialog{
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    width:min(480px, 92vw); border:1px solid var(--border); border-radius:12px;
    background:linear-gradient(180deg,#0f1520,#101a28); box-shadow:0 18px 60px rgba(0,0,0,.55); padding:16px;
  }
  .dialog h3{ margin:0 0 6px; font-size:18px }
  .dialog p{ margin:0 0 12px; color:var(--muted) }
  .dialog .row{ display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap; }
  .dialog button{
    padding:8px 12px; border:1px solid var(--border); border-radius:8px; background:#0e1726; color:#fff; font-weight:700; cursor:pointer;
  }
  .dialog button:hover{ background:#111b2a; }
  .dialog .danger{ background:linear-gradient(180deg,#2b0f14,#370c12); border-color:#4a1018; color:#ffb3bd; }

  .snackbar{
    position:fixed; left:50%; transform:translateX(-50%); bottom:16px; z-index:70;
    display:none; align-items:center; gap:12px; padding:10px 14px; border:1px solid var(--border); border-radius:12px;
    background:linear-gradient(180deg,#0f1520,#101a28); box-shadow:0 12px 40px rgba(0,0,0,.5); color:var(--ink);
  }
  .snackbar.show{ display:flex; }
  .snackbar button{ padding:6px 10px; border:1px solid var(--border); border-radius:8px; background:#0e1726; color:#fff; font-weight:700; cursor:pointer; }
  .snackbar button:hover{ background:#111b2a; }
  .snackbar .muted{ color:var(--muted); }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <h1>Guardian Command</h1>
        <span class="badge">S!ck on Tuesdays</span>
      </div>
    </header>

    <div class="layout">
      <!-- LEFT: Layout tabs -->
      <aside class="leftTabs">
        <div class="tabs" id="layoutTabs">
          <!-- rows injected here -->
          <button class="addBtn" id="addTabBtn">+ Add Tab</button>
          <div class="bulkBar">
            <button class="toggleBtn" id="bulkToggle" aria-pressed="false" title="Select multiple layouts to delete">Select layouts</button>
            <button class="deleteBtn" id="bulkDelete" disabled title="Select layouts to enable">Delete selected</button>
          </div>
          <div class="tabFooter muted">Each tab saves positions, sizes, visibility & color.</div>
        </div>
      </aside>

      <!-- TOP of GRID: controls (center lock, right visibility) -->
      <div class="controls">
        <div class="spacer"></div>
        <div class="center">
          <div id="lockToggle" role="button" tabindex="0" aria-pressed="false" title="Click to lock/unlock layout">
            <span class="dot" aria-hidden="true"></span><span class="text"></span>
          </div>
        </div>
        <div class="right">
          <div class="controlBox" id="panelControl">
            <div class="controlHeader"><span>Panels</span><span class="caret">▾</span></div>
            <div class="controlBody" id="panelList"></div>
          </div>
        </div>
      </div>

      <!-- GRID: information panels -->
      <main class="grid" id="grid">
        <section class="card" data-id="D" data-x="0" data-y="0" data-w="8" data-h="6">
          <div class="bar"><div class="title">Season Overview</div><div class="handle">⋮⋮</div></div>
          <div class="content">Main “hero” area. Other boxes can grow/shrink as you arrange.</div>
          <div class="resize" aria-hidden="true"></div>
        </section>
        <section class="card" data-id="Tools" data-x="8" data-y="0" data-w="4" data-h="2">
          <div class="bar"><div class="title">Tools</div><div class="handle">⋮⋮</div></div>
          <div class="content">DIM • light.gg • TodayInDestiny • D2 Foundry</div>
          <div class="resize" aria-hidden="true"></div>
        </section>
        <section class="card" data-id="Rotators" data-x="8" data-y="2" data-w="4" data-h="2">
          <div class="bar"><div class="title">Rotators</div><div class="handle">⋮⋮</div></div>
          <div class="content">Raid: Last Wish • Dungeon: Shattered Throne • Crucible: Momentum</div>
          <div class="resize" aria-hidden="true"></div>
        </section>
        <section class="card" data-id="Vendors" data-x="8" data-y="4" data-w="4" data-h="2">
          <div class="bar"><div class="title">Vendors</div><div class="handle">⋮⋮</div></div>
          <div class="content">Xûr & Banshee quick look.</div>
          <div class="resize" aria-hidden="true"></div>
        </section>
        <section class="card" data-id="Build" data-x="0" data-y="6" data-w="4" data-h="3">
          <div class="bar"><div class="title">Build Spotlight</div><div class="handle">⋮⋮</div></div>
          <div class="content">Warlock/Titan/Hunter builds.</div>
          <div class="resize" aria-hidden="true"></div>
        </section>
        <section class="card" data-id="Mods" data-x="4" data-y="6" data-w="4" data-h="3">
          <div class="bar"><div class="title">Modifiers</div><div class="handle">⋮⋮</div></div>
          <div class="content">Surges, threats, champions.</div>
          <div class="resize" aria-hidden="true"></div>
        </section>
        <section class="card" data-id="Clan" data-x="8" data-y="6" data-w="4" data-h="3">
          <div class="bar"><div class="title">Clan Ops</div><div class="handle">⋮⋮</div></div>
          <div class="content">Roster, fireteams, invites.</div>
          <div class="resize" aria-hidden="true"></div>
        </section>
        <section class="card" data-id="Telemetry" data-x="0" data-y="9" data-w="4" data-h="2">
          <div class="bar"><div class="title">Telemetry</div><div class="handle">⋮⋮</div></div>
          <div class="content">Status pings and simple stats.</div>
          <div class="resize" aria-hidden="true"></div>
        </section>
        <section class="card" data-id="Intel" data-x="4" data-y="9" data-w="8" data-h="2">
          <div class="bar"><div class="title">Intel Feed</div><div class="handle">⋮⋮</div></div>
          <div class="content">Announcements & patch highlights.</div>
          <div class="resize" aria-hidden="true"></div>
        </section>
      </main>
    </div>
  </div>

  <!-- Popover: color/rename + delete (single) -->
  <div class="popover" id="colorPopover" role="dialog" aria-modal="true" aria-hidden="true">
    <label for="tabName">Tab name</label>
    <input id="tabName" type="text" maxlength="30" />
    <label for="tabColor">Tab color</label>
    <input id="tabColor" type="color" />
    <div class="row">
      <button id="colorSave">Save</button>
      <button id="colorCancel">Cancel</button>
    </div>
    <button class="danger" id="colorDelete" title="Delete this tab">Delete Tab</button>
  </div>

  <!-- Confirm modal -->
  <div class="modal" id="confirmModal" aria-hidden="true">
    <div class="backdrop"></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="confirmTitle">
      <h3 id="confirmTitle">Delete tab(s)?</h3>
      <p id="confirmText">This will remove the selection and their saved layouts.</p>
      <div class="row">
        <button id="confirmCancel">Cancel</button>
        <button id="confirmDelete" class="danger">Delete</button>
      </div>
    </div>
  </div>

  <!-- Undo snackbar -->
  <div class="snackbar" id="undoBar" aria-live="polite">
    <span id="undoText" class="muted">Deleted.</span>
    <button id="undoBtn">Undo</button>
  </div>

<script>
(function(){
  const gridEl = document.getElementById('grid');
  const COLS = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cols')) || 12;
  const COLW = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--colW')) || 90;
  const ROWH = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--rowH')) || 90;

  /* ===== Cards ===== */
  const items = [...gridEl.querySelectorAll('.card')].map(el => ({
    el, id: el.dataset.id,
    x:+el.dataset.x, y:+el.dataset.y, w:+el.dataset.w, h:+el.dataset.h,
    hidden:false, minW:1, minH:1, maxW:COLS
  }));
  const DEFAULT_LAYOUT = items.map(({id,x,y,w,h,hidden}) => ({id,x,y,w,h,hidden}));

  /* ===== Storage keys ===== */
  const TABS_KEY='sot_tabs_meta_full';
  const LAYOUT_KEY_PREFIX='sot_layout_';
  const ACTIVE_TAB_KEY='sot_active_tab_id_full';

  /* ===== Tabs meta ===== */
  function loadTabsMeta(){
    const raw = localStorage.getItem(TABS_KEY);
    if (raw){ try{ const p=JSON.parse(raw); if(Array.isArray(p)&&p.length) return p; }catch{} }
    const seed=[{id:'layout1', name:'Layout 1', color:'#7dd3fc'}];
    localStorage.setItem(TABS_KEY, JSON.stringify(seed));
    return seed;
  }
  function saveTabsMeta(t){ localStorage.setItem(TABS_KEY, JSON.stringify(t)); }

  let tabs = loadTabsMeta();
  let activeTabId = localStorage.getItem(ACTIVE_TAB_KEY) || tabs[0].id;

  /* ===== Accent color per tab ===== */
  function setActiveAccent(hex){
    try{
      const {h,s,l}=hexToHsl(hex);
      const darker=hslToHex(h,s,Math.max(0,l-10));
      document.documentElement.style.setProperty('--arc', hex);
      document.documentElement.style.setProperty('--arc2', darker);
    }catch{}
  }
  function hexToHsl(H){ let r=0,g=0,b=0;
    if(H.length==4){r="0x"+H[1]+H[1];g="0x"+H[2]+H[2];b="0x"+H[3]+H[3];}
    else if(H.length==7){r="0x"+H[1]+H[2];g="0x"+H[3]+H[4];b="0x"+H[5]+H[6];}
    r/=255;g/=255;b/=255; let cmin=Math.min(r,g,b),cmax=Math.max(r,g,b),d=cmax-cmin,h=0,s=0,l=(cmax+cmin)/2;
    if(d!=0){ if(cmax==r) h=((g-b)/d)%6; else if(cmax==g) h=(b-r)/d+2; else h=(r-g)/d+4; h=Math.round(h*60); if(h<0)h+=360; s=d/(1-Math.abs(2*l-1));}
    s=Math.round(s*100); l=Math.round(l*100); return {h,s,l};
  }
  function hslToHex(h,s,l){ s/=100;l/=100; const c=(1-Math.abs(2*l-1))*s,x=c*(1-Math.abs((h/60)%2-1)),m=l-c/2;
    let r=0,g=0,b=0;
    if(0<=h&&h<60){r=c;g=x;b=0}else if(60<=h&&h<120){r=x;g=c;b=0}
    else if(120<=h&&h<180){r=0;g=c;b=x}else if(180<=h&&h<240){r=0;g=x;b=c}
    else if(240<=h&&h<300){r=x;g=0;b=c}else{r=c;g=0;b=x}
    const toHex=v=>('0'+Math.round((v+m)*255).toString(16)).slice(-2);
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
  }

  /* ===== Save/Load layout per tab (no auto-compact; preserves gaps) ===== */
  function saveLayout(tabId){
    const data = items.map(({id,x,y,w,h,hidden}) => ({id,x,y,w,h,hidden}));
    localStorage.setItem(LAYOUT_KEY_PREFIX + tabId, JSON.stringify(data));
  }
  function loadLayout(tabId){
    const raw = localStorage.getItem(LAYOUT_KEY_PREFIX + tabId);
    const data = raw ? JSON.parse(raw) : DEFAULT_LAYOUT;
    for(const it of items){
      const f = data.find(x=>x.id===it.id);
      if (f) Object.assign(it,{x:f.x,y:f.y,w:f.w,h:f.h,hidden:!!f.hidden});
      else { const d=DEFAULT_LAYOUT.find(x=>x.id===it.id); Object.assign(it,d||{x:0,y:0,w:3,h:2,hidden:false}); }
    }
    resolveAll(items); applyLayout(items);
  }

  /* ===== Apply positions to DOM (for either real items or a shadow copy) ===== */
  function applyLayout(list){
    list.forEach(it=>{
      const node = items.find(i=>i.id===it.id).el;  // use real node
      node.classList.toggle('hide', !!it.hidden);
      if(!it.hidden){
        node.style.transform=''; // clear any drag transform (caller may set it)
        node.style.gridColumn = `${it.x + 1} / span ${it.w}`;
        node.style.gridRow    = `${it.y + 1} / span ${it.h}`;
      }
      // update data-* only when applying to the real items list
      if (list === items) Object.assign(node.dataset, {x:it.x, y:it.y, w:it.w, h:it.h});
    });
    renderPanelList();
  }

  /* ===== Collision helpers (downward push only) ===== */
  function rectsOverlap(a,b){ if(a.hidden||b.hidden) return false;
    return !(a.x + a.w <= b.x || b.x + b.w <= a.x || a.y + a.h <= b.y || b.y + b.h <= a.y);
  }
  function getCollisions(target, list){ return list.filter(it=>it.id!==target.id && rectsOverlap(target, it)); }
  function pushDown(item, list){
    let colliders=getCollisions(item, list);
    while (colliders.length){
      for (const c of colliders){ c.y = item.y + item.h; }
      colliders=getCollisions(item, list);
    }
  }
  function resolveAll(list){
    // Process top-to-bottom, left-to-right
    const ordered = list.slice().sort((a,b)=>(a.y-b.y)||(a.x-b.x));
    for (const it of ordered){ pushDown(it, list); }
    return list;
  }
  function clampToCols(it){
    if (it.w > COLS) it.w = COLS;
    if (it.x < 0) it.x = 0;
    if (it.x + it.w > COLS) it.x = COLS - it.w;
    if (it.y < 0) it.y = 0;
  }

  /* ===== Right: Panel visibility ===== */
  const panelControl=document.getElementById('panelControl');
  const panelList=document.getElementById('panelList');
  panelControl.querySelector('.controlHeader').addEventListener('click', ()=> panelControl.classList.toggle('open'));
  function renderPanelList(){
    panelList.innerHTML='';
    for(const it of items){
      const row=document.createElement('label'); row.className='checkRow';
      row.innerHTML=`<input type="checkbox" ${!it.hidden?'checked':''} data-id="${it.id}"><span>${it.el.querySelector('.title')?.textContent||it.id}</span>`;
      panelList.appendChild(row);
    }
  }
  panelList.addEventListener('change', e=>{
    const cb=e.target.closest('input[type="checkbox"]'); if(!cb) return;
    const it=items.find(i=>i.id===cb.dataset.id); it.hidden=!cb.checked;
    resolveAll(items); applyLayout(items); saveLayout(activeTabId);
  });

  /* ===== Lock toggle (centered) ===== */
  const lockToggle=document.getElementById('lockToggle');
  let isLocked=false;
  function setLocked(v){ isLocked=!!v; document.body.classList.toggle('locked', isLocked); lockToggle.setAttribute('aria-pressed', String(isLocked)); }
  lockToggle.addEventListener('click', ()=>setLocked(!isLocked));
  lockToggle.addEventListener('keydown', e=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); setLocked(!isLocked); } });

  /* ===== Smooth Drag with LIVE push =====
     - While dragging: card follows cursor smoothly (transform)
     - We run a SHADOW layout based on the original positions to push others live
     - If you move back, others return (because each move recalculates from baseline)
     - On drop: snap to nearest grid, commit the shadow to real items
  */
  let dragging=null, startMouse=null, startPos=null;
  let dragBaseline=null;   // array of {id,x,y,w,h,hidden} at drag start
  let dragShadow=null;     // working copy updated on mousemove

  gridEl.addEventListener('mousedown', e=>{
    if (isLocked) return;
    const bar = e.target.closest('.bar'); if (!bar) return;
    const el  = bar.closest('.card'); const it = items.find(i=>i.el===el);
    dragging   = it;
    startMouse = {x:e.clientX, y:e.clientY};
    startPos   = {x:it.x, y:it.y};

    // snapshot baseline
    dragBaseline = items.map(o => ({ id:o.id, x:o.x, y:o.y, w:o.w, h:o.h, hidden:o.hidden }));
    dragShadow   = dragBaseline.map(o => ({ ...o }));

    it.el.classList.add('dragging');
    it.el.style.transform = `translate(0px,0px)`;
    e.preventDefault();
  });

  window.addEventListener('mousemove', e=>{
    if (!dragging) return;
    const dx = e.clientX - startMouse.x;
    const dy = e.clientY - startMouse.y;

    // Snap candidate for SHADOW reflow (so others can respond live)
    const gx = Math.round(dx / COLW);
    const gy = Math.round(dy / ROWH);
    const targetX = Math.max(0, startPos.x + gx);
    const targetY = Math.max(0, startPos.y + gy);

    // Rebuild shadow from baseline on every move (so moving back restores)
    dragShadow = dragBaseline.map(o => ({ ...o }));
    const sDrag = dragShadow.find(o => o.id === dragging.id);
    sDrag.x = targetX; sDrag.y = targetY;
    clampToCols(sDrag);
    resolveAll(dragShadow);

    // Apply shadow to DOM so neighbors move out of the way live
    applyLayout(dragShadow);

    // Keep the dragged card visually following the exact cursor (residual inside the snapped cell)
    const residualX = dx - gx * COLW;
    const residualY = dy - gy * ROWH;
    dragging.el.style.transform = `translate(${residualX}px, ${residualY}px)`;
  });

  window.addEventListener('mouseup', e=>{
    if (!dragging) return;
    const dx = e.clientX - startMouse.x;
    const dy = e.clientY - startMouse.y;

    // Final snap (already used for shadow); commit shadow to real items
    const gx = Math.round(dx / COLW);
    const gy = Math.round(dy / ROWH);
    const targetX = Math.max(0, startPos.x + gx);
    const targetY = Math.max(0, startPos.y + gy);

    dragShadow = dragBaseline.map(o => ({ ...o }));
    const sDrag = dragShadow.find(o => o.id === dragging.id);
    sDrag.x = targetX; sDrag.y = targetY;
    clampToCols(sDrag);
    resolveAll(dragShadow);

    // Commit to items
    for (const sh of dragShadow){
      const real = items.find(i => i.id === sh.id);
      Object.assign(real, { x:sh.x, y:sh.y, w:sh.w, h:sh.h, hidden:sh.hidden });
    }
    // Clear drag visuals and apply final layout
    dragging.el.classList.remove('dragging');
    dragging.el.style.transform = '';
    dragging = null; dragBaseline = null; dragShadow = null;

    applyLayout(items);
    saveLayout(activeTabId);
  });

  /* ===== Resizing (snap while resizing; can switch to smooth later) ===== */
  let resizing=null, startMouseR=null, startSize=null;
  gridEl.addEventListener('mousedown', e=>{
    if (isLocked) return;
    const h = e.target.closest('.resize'); if (!h) return;
    const el = h.closest('.card'); const it = items.find(i=>i.el===el);
    resizing = it; startMouseR = {x:e.clientX, y:e.clientY}; startSize = {w:it.w, h:it.h};
    it.el.classList.add('dragging'); e.preventDefault(); e.stopPropagation();
  });
  window.addEventListener('mousemove', e=>{
    if (!resizing) return;
    const dx=e.clientX-startMouseR.x, dy=e.clientY-startMouseR.y;
    const dw=Math.round(dx/COLW), dh=Math.round(dy/ROWH);
    resizing.w=Math.max(resizing.minW, Math.min(resizing.maxW, startSize.w+dw));
    resizing.h=Math.max(resizing.minH, startSize.h+dh);
    clampToCols(resizing); resolveAll(items); applyLayout(items);
  });
  window.addEventListener('mouseup', ()=>{
    if (!resizing) return;
    resizing.el.classList.remove('dragging'); resizing=null;
    applyLayout(items); saveLayout(activeTabId);
  });

  /* ===== Left Tabs (with bulk delete) ===== */
  const tabsEl=document.getElementById('layoutTabs');
  const addTabBtn=document.getElementById('addTabBtn');
  let bulkMode=false;
  const bulkToggle=document.getElementById('bulkToggle');
  const bulkDeleteBtn=document.getElementById('bulkDelete');
  const selectedIds=new Set();

  function renderTabs(){
    [...tabsEl.querySelectorAll('.tabRow')].forEach(n=>n.remove());
    const beforeNode=addTabBtn;
    tabs.forEach(t=>{
      const row=document.createElement('div'); row.className='tabRow';
      if(bulkMode){
        const chk=document.createElement('input'); chk.type='checkbox'; chk.className='tabCheck'; chk.dataset.id=t.id; chk.checked=selectedIds.has(t.id);
        row.appendChild(chk);
      }else{
        const chip=document.createElement('div'); chip.className='colorChip'; chip.style.background=t.color; chip.dataset.id=t.id; row.appendChild(chip);
      }
      const btn=document.createElement('button'); btn.type='button'; btn.className='tabBtn'; btn.textContent=t.name; btn.dataset.tab=t.id;
      if(t.id===activeTabId) btn.classList.add('active');
      row.appendChild(btn);
      tabsEl.insertBefore(row, beforeNode);
    });
    updateBulkButtons();
  }
  function updateActiveInUI(){ for(const b of tabsEl.querySelectorAll('.tabBtn')) b.classList.toggle('active', b.dataset.tab===activeTabId); }
  function getTabMeta(id){ return tabs.find(t=>t.id===id); }
  function setActiveTab(id){
    if(!getTabMeta(id)) return;
    saveLayout(activeTabId);
    activeTabId=id; localStorage.setItem(ACTIVE_TAB_KEY, activeTabId);
    const meta=getTabMeta(activeTabId);
    setActiveAccent(meta.color); loadLayout(activeTabId); updateActiveInUI();
  }

  addTabBtn.addEventListener('click', ()=>{
    const nextIndex=(()=>{ const nums=tabs.map(t=>parseInt((t.id.match(/\d+$/)||[1])[0],10)); return Math.max(...nums,0)+1; })();
    const newId='layout'+nextIndex;
    const cur=getTabMeta(activeTabId);
    const meta={id:newId, name:`Layout ${nextIndex}`, color:cur?.color||'#7dd3fc'};
    tabs.push(meta); saveTabsMeta(tabs);
    saveLayout(newId); setActiveTab(newId); renderTabs(); updateActiveInUI();
  });

  tabsEl.addEventListener('click', e=>{
    const btn=e.target.closest('.tabBtn');
    if (btn){
      if (bulkMode) return;
      if (btn.dataset.tab===activeTabId) return;
      setActiveTab(btn.dataset.tab); return;
    }
    const chip=e.target.closest('.colorChip'); if(chip){ openPopoverFor(chip.dataset.id, chip); }
  });

  bulkToggle.addEventListener('click', ()=>{
    bulkMode = !bulkMode; bulkToggle.setAttribute('aria-pressed', String(bulkMode));
    selectedIds.clear(); closePopover(); renderTabs();
  });
  tabsEl.addEventListener('change', e=>{
    const chk=e.target.closest('.tabCheck'); if(!chk) return;
    if(chk.checked) selectedIds.add(chk.dataset.id); else selectedIds.delete(chk.dataset.id);
    updateBulkButtons();
  });
  function updateBulkButtons(){
    const allCount=tabs.length, selCount=selectedIds.size;
    const canDelete = selCount>0 && selCount<allCount;
    bulkDeleteBtn.disabled = !canDelete;
    bulkDeleteBtn.classList.toggle('enabled', canDelete);
    bulkDeleteBtn.title = canDelete ? `Delete ${selCount} selected` : (selCount===allCount ? 'Keep at least one layout' : 'Select layouts to enable');
  }

  /* ===== Single tab popover ===== */
  const pop=document.getElementById('colorPopover');
  const nameInput=document.getElementById('tabName');
  const colorInput=document.getElementById('tabColor');
  const saveBtn=document.getElementById('colorSave');
  const cancelBtn=document.getElementById('colorCancel');
  const deleteBtn=document.getElementById('colorDelete');
  let popTargetId=null;

  function openPopoverFor(tabId, anchorEl){
    if (bulkMode) return;
    if (document.body.classList.contains('locked')) return;
    const meta=getTabMeta(tabId); if(!meta) return;
    popTargetId=tabId; nameInput.value=meta.name; colorInput.value=meta.color; deleteBtn.disabled=(tabs.length<=1);
    const r=anchorEl.getBoundingClientRect();
    pop.style.top=`${r.bottom+8}px`; pop.style.left=`${Math.max(12, r.left-20)}px`;
    pop.classList.add('open'); pop.setAttribute('aria-hidden','false'); setTimeout(()=>nameInput.focus(),0);
  }
  function closePopover(){ pop.classList.remove('open'); pop.setAttribute('aria-hidden','true'); popTargetId=null; }

  saveBtn.addEventListener('click', ()=>{
    const meta=getTabMeta(popTargetId); if(!meta) return;
    meta.name = nameInput.value.trim() || meta.name;
    meta.color = colorInput.value;
    saveTabsMeta(tabs); renderTabs(); updateActiveInUI(); if(popTargetId===activeTabId) setActiveAccent(meta.color); closePopover();
  });
  cancelBtn.addEventListener('click', closePopover);

  /* ===== Confirm + Undo (bulk/single) ===== */
  const confirmModal=document.getElementById('confirmModal');
  const confirmText=document.getElementById('confirmText');
  const confirmDeleteBtn=document.getElementById('confirmDelete');
  const confirmCancelBtn=document.getElementById('confirmCancel');
  const undoBar=document.getElementById('undoBar');
  const undoText=document.getElementById('undoText');
  const undoBtn=document.getElementById('undoBtn');
  let confirmIds=[];
  let undoTimer=null;
  let undoPayload=null;

  function openConfirm(ids){
    confirmIds = ids.slice();
    if (ids.length>1){
      const names = ids.map(id=>getTabMeta(id)?.name||id);
      const sample = names.slice(0,3).join(', ')+(names.length>3?` +${names.length-3} more`:'');
      confirmText.textContent = `Delete ${ids.length} layout(s): ${sample}? This will remove them and their saved layouts.`;
    }else{
      const meta=getTabMeta(ids[0]); confirmText.textContent=`This will delete “${meta?.name||ids[0]}” and its saved layout.`;
    }
    confirmModal.classList.add('open'); confirmModal.setAttribute('aria-hidden','false');
  }
  function closeConfirm(){ confirmModal.classList.remove('open'); confirmModal.setAttribute('aria-hidden','true'); confirmIds=[]; }

  function showUndo(payload){
    undoPayload=payload;
    const names=payload.metas.map(m=>m.name);
    const label = names.length>1 ? `Deleted ${names.length} layouts: ${names.slice(0,3).join(', ')}${names.length>3?` +${names.length-3} more`:''}.` : `Deleted “${names[0]}”.`;
    undoText.textContent=label;
    undoBar.classList.add('show'); clearTimeout(undoTimer);
    undoTimer=setTimeout(()=>{ undoBar.classList.remove('show'); undoPayload=null; }, 8000);
  }

  undoBtn.addEventListener('click', ()=>{
    if(!undoPayload) return;
    const { metas, layouts, indices, prevActiveId } = undoPayload;
    metas.forEach((m, i)=> tabs.splice(indices[i], 0, m));
    saveTabsMeta(tabs);
    for(const id in layouts){ localStorage.setItem(LAYOUT_KEY_PREFIX + id, layouts[id]); }
    renderTabs();
    const restoreId = tabs.find(t=>t.id===prevActiveId)?.id || metas[0].id;
    setActiveTab(restoreId);
    undoBar.classList.remove('show'); undoPayload=null;
  });

  document.getElementById('bulkDelete').addEventListener('click', ()=>{
    const sel=[...selectedIds];
    if (sel.length===0) return;
    if (sel.length>=tabs.length) return;
    openConfirm(sel);
  });
  deleteBtn.addEventListener('click', ()=>{
    if (tabs.length<=1) return;
    const id=popTargetId; closePopover(); openConfirm([id]);
  });
  confirmCancelBtn.addEventListener('click', closeConfirm);
  document.querySelector('#confirmModal .backdrop').addEventListener('click', closeConfirm);

  confirmDeleteBtn.addEventListener('click', ()=>{
    if (confirmIds.length===0) { closeConfirm(); return; }
    const deletingIds = confirmIds.slice();
    const metas=[], indices=[], layouts={}, prevActiveId=activeTabId;
    deletingIds.sort((a,b)=> tabs.findIndex(t=>t.id===a) - tabs.findIndex(t=>t.id===b));
    deletingIds.forEach(id=>{
      const idx=tabs.findIndex(t=>t.id===id); const meta=tabs[idx];
      metas.push({...meta}); indices.push(idx);
      const key=LAYOUT_KEY_PREFIX+id; const json=localStorage.getItem(key); if(json) layouts[id]=json;
    });
    const remaining = tabs.filter(t=>!deletingIds.includes(t.id));
    if (remaining.length<1){ closeConfirm(); alert('At least one layout must remain.'); return; }

    deletingIds.forEach(id=> localStorage.removeItem(LAYOUT_KEY_PREFIX+id));
    tabs = remaining; saveTabsMeta(tabs);

    if (deletingIds.includes(activeTabId)){
      const fallback = tabs[Math.max(0, (indices[0]-1))] || tabs[0];
      activeTabId=fallback.id; localStorage.setItem(ACTIVE_TAB_KEY, activeTabId);
      setActiveAccent(fallback.color); loadLayout(activeTabId);
    }
    renderTabs(); updateActiveInUI();
    selectedIds.clear(); if (bulkMode){ bulkMode=false; bulkToggle.setAttribute('aria-pressed','false'); renderTabs(); }
    showUndo({ metas, layouts, indices, prevActiveId });
    closeConfirm();
  });

  document.addEventListener('keydown', e=>{
    if(e.key==='Escape'){
      if(document.getElementById('confirmModal').classList.contains('open')) closeConfirm();
      if(document.getElementById('colorPopover').classList.contains('open')) closePopover();
    }
  });
  document.addEventListener('click', e=>{
    const popEl=document.getElementById('colorPopover');
    if(!popEl.classList.contains('open')) return;
    if(e.target.closest('#colorPopover') || e.target.closest('.colorChip')) return;
    closePopover();
  });

  /* ===== Init ===== */
  if(!tabs.find(t=>t.id===activeTabId)) activeTabId=tabs[0].id;
  localStorage.setItem(ACTIVE_TAB_KEY, activeTabId);
  (function setInitialAccent(){ const meta=tabs.find(t=>t.id===activeTabId) || tabs[0]; if (meta) setActiveAccent(meta.color); })();
  loadLayout(activeTabId);
  renderTabs();
  renderPanelList();
  setLocked(false);
})();
</script>
</body>
</html>
